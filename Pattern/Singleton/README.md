# Singleton
プロジェクト内で必ず一つしかインスタンス化されないクラスを作るパターン。  
単語の意味：1枚札の。一つの

```
クラスがインスタンスを1つしか持たないことを保証し、
そのインスタンスにアクセスするグローバルポイントを提供します。
```

## 使い所
- プロジェクト内で一つしかインスタンスとならない場合に、そのことを保証することで、  
インスタンス間での整合性などを担保することができる。
- システム全体の設定データを管理するクラスなど
- HWとのアクセスを行うクラスなど

### 現代では非推奨のパターンでも有る
#### 課題
1. グローバルなアクセスポイントを用意するため、  
バグの混入を招き、また解析が難しくなる。
    - 基本的にはグローバル変数など全体からアクセスできる状況は良くない

2. 遅延初期化はメリットだけではない。
    - いつインスタンス化されるか制御できないので負荷の高いタイミングに重なるとバグになる

#### 解決策
1. そもそも単一の`クラス`とする必要があるのか？
    - `Singleton`のメソッドを既存の`クラス`に移せば`クラス`にする必要すらない

2. コンストラクタを工夫して1つ以上のインスタンスができないようにする。  
グローバルなアクセスポイントを提供しない。  
[HeadFirstのPythonの実装方法](#pythonの実装方法)など

3. インスタンスへのアクセス方法の提供方法を変える。
    1. 引数渡し(`依存性の注入`の活用)
    2. 基底クラスからの継承(基底クラスにアクセスするメソッドを用意してサブクラスだけアクセスできるようにする)
    3. 他のグローバルなデータから取得する(ぶっちゃけこれはあまり意味が無いように感じる・・・)
    4. サービスロケータかｒ取得する(他デザインパターンの活用(多分GoFとは違うパターン))


## ピーコック アンダーソン
### 実装方法(C#の場合)
2つの実装方法がある。staticクラスを作れる場合はstaticクラスを使う。
- staticクラス：継承ができない制約がある。
- コンストラクタをprivateにする：コンストラクタをprivateにすることで、コンストラクタの使用タイミングを管理する。 
    - コンストラクタをprivateにする
    - GetInstance()メソッドを用意してインスタンスにアクセスできるようにする。
    - 1回目のアクセス時にインスタンス化を行う
    - staticでクラス自身が自分のインスタンスを保持するようにする
    - 非同期でのアクセスがある場合は、LookObjectなどを使って、アクセスタイミングを制御する。または、プロパティで初期化する。
    
### ポイント
- newできないようにする -> 他クラスからインスタンス化できないようにする。
- インスタンスにアクセスできないようにする -> GetInstance()などでアクセスを制限する。
- statciクラスが使えるなら使う。
- 非同期処理は気をつける。 -> 複数でアクセスすると不整合やデットロックなどバグになる。
- テストコードでも1つしか無いので、前のテストの影響を受けるので単体テストで考慮が必要。

### テストコードで考慮するべき内容
テストコードの場合に他のテストの影響を受けるため、テストの実施順によってテスト結果が変わる可能性がある。
- テストを実行する前にシングルトンのインスタンスを初期状態にする。  
-> テストイニシャライズなどテストフレームワークにはテスト実行前に必ず実行する処理を書く箇所がある。
- 複数のテストクラスでシングルトンのクラスを使う必要がある場合は、ベースのテストクラスを作成して、各テストクラスで継承することでイニシャライズ処理を複数書く必要がなくなる。 

## HeadFirst
### Pythonの実装方法
- `__new__(cls)`を使って実装する。  
- メンバー変数が有る場合は、`__init__(self)`は例外を出力するように設定する。
- Pythonの場合は、`get_instance()`メソッドなどはいらない
    ``` python 
    class ChocolateBoiler:
        _instance = None

        def __new__(cls):
            if cls._instance is None:
                cls._instance = super().__new__(cls)
            return cls._instance

        def __init__(self):
            self._is_empty = True
            self._is_boiled = False
    ```
- メンバー変数が無い場合は、`__init__(self)`は例外を出力するように設定することもできる。  
ただ、例外を発生させられるだけで意味は無いかも・・・
    ```python
    class Singleton:
        def __init__(self):
            raise NotImplementedError()

        unique_instance = None

        @classmethod
        def get_instance(cls):
            if cls.unique_instance is None:
                cls.unique_instance = cls.__new__(cls)
            return cls.unique_instance
    ```

### クラス図
``` plantuml
@startuml
class Singleton {
    instance
    __new__(): instance
    __init__()
}

note left of Singleton::__new__()
    インスタンスが1つであることを
    保証するコンストラクタ
    メンバーの`instance`を返す 
end note

note right of Singleton::__init__()
    メンバー変数が他にいる場合は
    初期化するメソッド
end note
@enduml
```


### テストコードで気をつけること
- テストコード内でもインスタンスが1つしか無いため、前回のテストの状態によってテスト結果が変わる。
    - テスト前に必ず初期化処理を実施するようにする。
    - Singletonには状態を初期化するメソッドが必要になる。

## デザインパターン入門
### 関連パターン

- 一覧

|name|分類|概要|
|---|---|---|
|Abstract Factory|類似|本パターンは1つのインスタンスで有ることが多い。|
|Builder|類似|本パターンは1つのインスタンスで有ることが多い。|
|Facade|類似|本パターンは1つのインスタンスで有ることが多い。|
|Prototype|類似|本パターンは1つのインスタンスで有ることが多い。|

``` plantuml
@startuml
類似 -- AbstractFactory
類似 -- Builder
類似 -- Facade
類似 -- Prototype
@enduml
```
